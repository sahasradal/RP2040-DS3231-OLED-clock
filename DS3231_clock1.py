from machine import Pin, I2C

import utime,uarray

 

DS3231_address = 0x68				# RTC I2C address
OLEDaddress=  0x3C					# OLED I2c address
command=  0x00						# OLED operational command
data_cmd=  0x40						# OLED data RAM command
Cstart=0							# used to store OLED start column address
Cend=0								# used to store OLED end column address
Pstart=0							# used to store OLED page start address
Pend=0								# used to store OLED page end address
debounce_delay =100					# debounce delay 100ms
minute=0							# used to store user selected minutes to set time
hour=0								# used to store user selected hour to set time
day=1								# used to store user selected day of week to set time
date=1								# used to store user selected date to set calander
month=1								# used to store user selected month to set calander
year=0								# used to store user selected year to set calander
last_press_time = utime.ticks_ms()	# stop watch variable for switch debounce


def page_address_mode():						# OLED
    buf=bytearray([command,0x20,0x02])
    i2c.writeto(OLEDaddress,buf,True)

def vertical_address_mode():					# OLED
    buf=bytearray([command,0x20,0x01])
    i2c.writeto(OLEDaddress,buf,True)

def horizontal_address_mode():					# OLED
    buf=bytearray([command,0x20,0x00])
    i2c.writeto(OLEDaddress,buf,True)

def set_column_address(a,b):  					#0-127 vertical & horizontal mode only  OLED
    global Cstart,Cend
    Cstart=a									# write starts in this column
    Cend=b										# write ends in this column
    buf=bytearray([command,0x21])
    buf.extend(bytes([Cstart]))
    buf.extend(bytes([Cend]))
    i2c.writeto(OLEDaddress,buf,True)

def set_page_address(a,b): 						#0-3  vertical & horizontal mode only
    global Pstart,Pend
    Pstart=a									# starting page
    Pend=b										# ending page
    buf=bytearray([command,0x22])
    buf.extend(bytes([Pstart]))
    buf.extend(bytes([Pend]))
    i2c.writeto(OLEDaddress,buf,True)

def set_page_startaddress_PA(PAstart): 			# only for page addressing mode
    buf=bytearray([command])
    buf1=0xb0 | PAstart
    buf.extend(buf1)
    i2c.writeto(OLEDaddress,buf,True)

###########################################################################
def push_cursor(): # for 8x16 fonts only , advances cursor left by 8 columns and on reaching 127th column shifts cursor to page 2,3 from page 0,1
    global Pstart,Pend,Cstart,Cend
    if Cend < 127:
        set_column_address((Cstart+8),(Cend+8))
    if Cend == 127 and Pstart==0:
        set_page_address(2,3)
        set_column_address(0,7)
    if Cend == 127 and Pstart==2:
        set_page_address(0,1)
        set_column_address(0,7)

###############################################################

#Function to clear 128x4 OLED display screen

def clear_display():
    set_cursor_00()                                          # set cursor to 0,0
    buf=bytearray([data_cmd])                                # load data_cmd in buffer, tells oled data is being send
    buf1=bytearray([0x00]*(128*4))                   # create a byte array of 128x4 zeros.
    buf.extend(buf1)
    i2c.writeto(OLEDaddress,buf,True)                  # transmit data command to OLED

##############################################################
# function sets the OLED cursor to 0,0 for vertical mode
def set_cursor_00():                                           # positions cursor at 0,0 = x,y
    global Cstart, Cend, Pstart, Pend                      # Declare global variables
    buf=bytearray([command ,0x22,0x00,0x03,0x21,0x00,0x7f]) # register 0x22 for Y start at 0 and end at page 3
    Cstart = 0
    Cend = Cstart + 8  # Each character occupies 8 columns
    Pstart = 0
    Pend = Pstart + 1
    i2c.writeto(OLEDaddress,buf,True)                   # register 0x21 for X cordinate, start at 0 end at 127

##################################################################    

# used to set cursor in horizontal write mode using 16x8 font
def set_cursor(x,y):
    global Pstart,Pend,Cstart,Cend
    set_column_address(x,(x+7))
    set_page_address(y,(y+1))
##########################################################################
    
    # for ascii char suppiled returns 16 fonts as byte array from the font array
def print_font_bytes(fonts, ascii_char): 
    # Calculate the index based on the ASCII value
    index = ord(ascii_char) - 32  # ' ' (space) is at index 0
    start_index = index * 16						# Calculate the start and end indices for slicing
    end_index = start_index + 16
    # Check if the calculated indices are within the bounds of the bytearray
    if start_index >= len(fonts) or end_index > len(fonts):
        print(f"Index out of range for character '{ascii_char}'.")
        return
    segment = fonts[start_index:end_index]			# Slice the bytearray to get the specific 16 bytes
    return bytearray(segment)

##################################################################

def print_char16(char):    						# call with horizontal addressing for 8x16 fonts
    font16=print_font_bytes(H16font, char)
    buf=bytearray([data_cmd])
    buf.extend(font16)
    i2c.writeto(OLEDaddress,buf,True)

###############################################################
    # function reads 3 bytes from DS3231 RTC and prints to OLED , RTC values are BCD
def read_time():
    buf = bytearray([0x00])
    i2c.writeto(DS3231_address,buf,False)
    time=i2c.readfrom(DS3231_address,3,True)
    BCD = time[0]
    sec1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    sec0= chr((BCD & 0x0f)  | 0x30)
    BCD = time[1]
    min1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    min0= chr((BCD & 0x0f)  | 0x30)
    BCD = time[2]
    hour1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    hour0= chr((BCD & 0x0f)  | 0x30)
    time_string=''.join([hour1,hour0,':',min1,min0,':',sec1,sec0])
    set_cursor(0,0)
    for item in time_string:
        print_char16(item)
        push_cursor()
    return time_string
############################################################################
#function to display numbers that user will choose with save/next buttons and write them to set time and calender
def write_time():
    global minute,hour,day,date,month,year,last_press_time
    set_hour()
    set_minute()
    set_day()
    set_date()
    set_month()
    set_year()
    buf=bytearray([0x00,0x00,minute,hour,day,date,month,year])  # 0x00 RTC register ,next 0x00 is seconds
    i2c.writeto(DS3231_address,buf,True)
########################################################################
# sub-function of write_time()
def set_hour():
    global minute,hour,day,date,month,year,last_press_time
    clear_display()
    set_cursor(0,0)
    message="adj hour"
    for char in message:
        print_char16(char)
        push_cursor()
    utime.sleep(2)
    clear_display()
    set_cursor(0,0)
    hour_counter = 0  # Initialize the hour counter
    while True:  # Outer loop to adjust hour
        # Convert the counter to BCD
        bcd = (hour_counter // 10) << 4 | (hour_counter % 10)
        char10=chr(((bcd & 0xf0)>>4)|0x30)
        char1=chr((bcd & 0x0f)|0x30)
        set_cursor(0,0)
        print_char16(char10)
        push_cursor()
        print_char16(char1)
        push_cursor()
        utime.sleep(.5)
        while True:
            current_time = utime.ticks_ms()
            if not save_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    hour = bcd
                    last_press_time = current_time   
                    return True
            if not next_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    last_press_time = current_time
                    hour_counter +=1
                    if hour_counter >= 24:
                        hour_counter = -1  # Reset to 0 if it exceeds 23
                        continue  # Start the outer loop over again immediately
                    break

########################################################################
# sub-function of write_time()
def set_minute():
    global minute,hour,day,date,month,year,last_press_time
    clear_display()			# clear OLED display
    set_cursor(0,0)			# set OLED cursor to 0,0 top left corner
    message="adj minute"	# display message adjust minute
    for char in message:	# loop writes characters of string to oled
        print_char16(char)	# function to write 16x8 fonts to OLED
        push_cursor()		# advace cursor after each character
    utime.sleep(2)			# 2 seconds time to see the message
    clear_display()			# clear message
    set_cursor(0,0)			# set cursor to 0,0
    minute_counter = 0  	# Initialize the minute counter used by BCD generator
    while True:  			# Outer loop to adjust hour
        # Convert the counter to BCD
        bcd = (minute_counter // 10) << 4 | (minute_counter % 10)  # binary coded decimal is output for each number in the minute counter, RTC needs BCD
        char10=chr(((bcd & 0xf0)>>4)|0x30)			# extract upper nibble and OR with ascii 0(0x30) to display 10th digit
        char1=chr((bcd & 0x0f)|0x30)				# extract the bottom nibble and OR with ascii 0 to display the unit position
        set_cursor(0,0)								# set OLED cursor to 0,0 position
        print_char16(char10)						# print 10th position of minute
        push_cursor()								# advance cursor
        print_char16(char1)							# print unit position on OLED
        push_cursor()								# advace cursor
        utime.sleep(.5)								# 500ms time delay for current BCD to be displayed to user, so that he can choose
        while True:
            current_time = utime.ticks_ms()			# start ms stopwatch
            if not save_sw.value():           		# if save switch is 0
                if(current_time - last_press_time) > debounce_delay:    # wait 100ms debounce time, if greater than 100ms
                    minute = bcd					# store current BCD in minute register as save switch is presed
                    last_press_time = current_time  # update last press time
                    return True						# EXIT the routine as minute is selected by user
            if not next_sw.value():           		# if next switch  is 0 due to pressing
                if(current_time - last_press_time) > debounce_delay:        # wait 100ms debounce time, if greater than 100ms
                    last_press_time = current_time  # update last press time	
                    minute_counter +=1				# increase minute counter by 1 as user didnt choose the previous number by pressing next
                    if minute_counter >= 60:		# check whether the minute counter is less than 60 minutes
                        minute_counter = -1  		# Reset to 0 if it exceeds 60
                        continue  					# Start the outer loop over again immediately
                    break							# jump to next BCD conversion
##################################################################################
# sub-function of write_time()
def set_day():
    global minute,hour,day,date,month,year,last_press_time
    clear_display()
    set_cursor(0,0)
    message="adj day"
    for char in message:
        print_char16(char)
        push_cursor()
    utime.sleep(2)
    clear_display()
    set_cursor(0,0)
    day_counter = 1  # Initialize the hour counter
    while True:  # Outer loop to adjust hour
        # Convert the counter to BCD
        bcd = (day_counter // 10) << 4 | (day_counter % 10)
        char10=chr(((bcd & 0xf0)>>4)|0x30)
        char1=chr((bcd & 0x0f)|0x30)
        set_cursor(0,0)
        print_char16(char10)
        push_cursor()
        print_char16(char1)
        push_cursor()
        utime.sleep(.5)
        while True:
            current_time = utime.ticks_ms()
            if not save_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    day = bcd
                    last_press_time = current_time   
                    return True
            if not next_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    last_press_time = current_time
                    day_counter +=1
                    if day_counter >= 8:
                        day_counter = 0  # Reset to 0 if it exceeds 23
                        continue  # Start the outer loop over again immediately
                    break
#################################################################################
# sub-function of write_time()
def set_date():
    global minute,hour,day,date,month,year,last_press_time
    clear_display()
    set_cursor(0,0)
    message="adj date"
    for char in message:
        print_char16(char)
        push_cursor()
    utime.sleep(2)
    clear_display()
    set_cursor(0,0)
    date_counter = 1  # Initialize the hour counter
    while True:  # Outer loop to adjust hour
        # Convert the counter to BCD
        bcd = (date_counter // 10) << 4 | (date_counter % 10)
        char10=chr(((bcd & 0xf0)>>4)|0x30)
        char1=chr((bcd & 0x0f)|0x30)
        set_cursor(0,0)
        print_char16(char10)
        push_cursor()
        print_char16(char1)
        push_cursor()
        utime.sleep(.5)
        while True:
            current_time = utime.ticks_ms()
            if not save_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    date = bcd
                    last_press_time = current_time   
                    return True
            if not next_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    last_press_time = current_time
                    date_counter +=1
                    if date_counter >= 32:
                        date_counter = 0  # Reset to 0 if it exceeds 23
                        continue  # Start the outer loop over again immediately
                    break
###################################################################################                
# sub-function of write_time()
def set_month():
    global minute,hour,day,date,month,year,last_press_time
    clear_display()
    set_cursor(0,0)
    message="adj month"
    for char in message:
        print_char16(char)
        push_cursor()
    utime.sleep(2)
    clear_display()
    set_cursor(0,0)
    month_counter = 1  # Initialize the hour counter
    while True:  # Outer loop to adjust hour
        # Convert the counter to BCD
        bcd = (month_counter // 10) << 4 | (month_counter % 10)
        char10=chr(((bcd & 0xf0)>>4)|0x30)
        char1=chr((bcd & 0x0f)|0x30)
        set_cursor(0,0)
        print_char16(char10)
        push_cursor()
        print_char16(char1)
        push_cursor()
        utime.sleep(.5)
        while True:
            current_time = utime.ticks_ms()
            if not save_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    month = bcd
                    last_press_time = current_time   
                    return True
            if not next_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    last_press_time = current_time
                    month_counter +=1
                    if month_counter >= 13:
                        month_counter = 0  # Reset to 0 if it exceeds 23
                        continue  # Start the outer loop over again immediately
                    break
######################################################################## 
# sub-function of write_time()
def set_year():
    global minute,hour,day,date,month,year,last_press_time
    clear_display()
    set_cursor(0,0)
    message="adj year"
    for char in message:
        print_char16(char)
        push_cursor()
    utime.sleep(2)
    clear_display()
    set_cursor(0,0)
    year_counter = 0  # Initialize the hour counter
    while True:  # Outer loop to adjust hour
        # Convert the counter to BCD
        bcd = (year_counter // 10) << 4 | (year_counter % 10)
        char10=chr(((bcd & 0xf0)>>4)|0x30)
        char1=chr((bcd & 0x0f)|0x30)
        set_cursor(0,0)
        print_char16(char10)
        push_cursor()
        print_char16(char1)
        push_cursor()
        utime.sleep(.5)
        while True:
            current_time = utime.ticks_ms()
            if not save_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    year = bcd
                    last_press_time = current_time   
                    return True
            if not next_sw.value():           # if tuneup sw is 0
                if(current_time - last_press_time) > debounce_delay:
                    last_press_time = current_time
                    year_counter +=1
                    if year_counter >= 100:
                        year_counter = 0  # Reset to 0 if it exceeds 23
                        continue  # Start the outer loop over again immediately
                    break

#################################################################
# function reads time ,date and week day from DS3231 RTC and outputs a time_string, date_string
def read_time_date():
    week_map = {
        1: "Mon",
        2: "Tue",
        3: "Wed",
        4: "Thu",
        5: "Fri",
        6: "Sat",
        7: "Sun",
    }

    buf = bytearray([0x00])
    i2c.writeto(DS3231_address,buf,False)
    time=i2c.readfrom(DS3231_address,7,True)
    BCD = time[0]
    sec1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    sec0= chr((BCD & 0x0f)  | 0x30)
    BCD = time[1]
    min1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    min0= chr((BCD & 0x0f)  | 0x30)
    BCD = time[2]
    hour1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    hour0= chr((BCD & 0x0f)  | 0x30)
    BCD = time[3]
    day = (BCD & 0x07)
    day_name=week_map.get(day,"unknown")
    BCD = time[4]
    date1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    date0= chr((BCD & 0x0f)  | 0x30)
    BCD = time[5]
    month1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    month0= chr((BCD & 0x0f)  | 0x30)
    BCD = time[6]
    year1= chr(((BCD & 0xf0) >> 4 ) | 0x30)
    year0= chr((BCD & 0x0f)  | 0x30)
    time_string= ''.join([hour1,hour0,':',min1,min0,':',sec1,sec0])
    date_string=''.join([day_name,"  " ,date1,date0,"-",month1,month0,"-","20",year1,year0])
    set_cursor(0,0)    # set cursor to column0 and page0  ,uses page0,1
    for item in time_string:
        print_char16(item)
        push_cursor()
    set_cursor(0,2)    # set cursor to column0 on page2 , uses pages 2,3
    for item in date_string:
        print_char16(item)
        push_cursor()
    return time_string , date_string
#############################################################
# init bytes for OLED with vertical addressing
OLED_INIT_BYTES = uarray.array('B',[0xA8,0x1f, 0x20,0x01, 0x21,0x00, 0x7F,0x22, 0x00,0x03, 0xDA,0x02, 0x8D,0x14, 0xAF,0x00])
#/* Standard ASCII 8x16 font */
# ssd1306xled_font8x16
H16font=bytearray([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

  0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,

  0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

  0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,

  0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,

  0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,

  0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,

  0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

  0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,

  0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,

  0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,

  0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,

  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,

  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,

  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,

  0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,

  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,

  0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,

  0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,

  0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,

  0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,

  0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,

  0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,

  0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,

  0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,

  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,

  0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,

  0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,

  0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,

  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,

  0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,

  0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,

  0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,

  0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,

  0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,

  0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,

  0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,

  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,

  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,

  0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,

  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,

  0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,

  0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,

  0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,

  0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,

  0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,

  0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,

  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,

  0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,

  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,

  0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,

  0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,

  0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,

  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,

  0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,

  0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,

  0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,

  0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,

  0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,

  0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,

  0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,

  0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,

  0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,

  0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,

  0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,

  0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,

  0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,

  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,

  0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,

  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,

  0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,

  0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,

  0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,

  0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,

  0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,

  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,

  0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,

  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,

  0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,

  0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,

  0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,

  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,

  0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,

  0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,

  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,

  0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,

  0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,

  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,

  0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,

  0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,

  0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,

  0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,

  0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])

# ----------------------------------------------------------------------------


#################################################################
# Switch Initializations

next_sw=machine.Pin(0,mode=Pin.IN,pull=Pin.PULL_UP) # tune up switch
save_sw=machine.Pin(1,mode=Pin.IN,pull=Pin.PULL_UP) # tune down switch
adj_sw =machine.Pin(4,mode=Pin.IN,pull=Pin.PULL_UP) # tune down switch
# I2C Initialization
i2c = I2C(id=0,scl=Pin(9),sda=Pin(8),freq=100_000)
#write_time()
buf=bytearray([command])                            #create a bytearray with i element and assign as buf
buf.extend(bytearray(OLED_INIT_BYTES))
i2c.writeto(OLEDaddress,buf,True)         			# write oed command 0x00 , no stop
utime.sleep_ms(10)                                 	# 10ms delay
clear_display()										# clear display
set_cursor_00()										# cursor at 0,0
horizontal_address_mode()							# change OLED addressing mode to horizontal (using 2 pages)
 
while True:
    read_time_date()								# reads time and date and displays on OLED
    current_time = utime.ticks_ms()			
    if not adj_sw.value():           				# if adjust sw is 0 , IF adjust switch is pressed time_write() function is called and time setting can be done
        if(current_time - last_press_time) > debounce_delay:
            write_time()
            last_press_time = current_time
    utime.sleep(1)									# 1 second delay

 

 

 